<!DOCTYPE html>
<html>
<head>
<title>Homeschool Time Tracker</title>
<style>
body { font-family: Arial, sans-serif; max-width: 1400px; margin: 20px auto; padding: 0 20px; }
h1 { color: #333; margin-bottom: 10px; }
.container { display: grid; grid-template-columns: 250px 1fr; gap: 20px; }
.sidebar { display: flex; flex-direction: column; gap: 15px; }
.panel { border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: #f9f9f9; }
.main-panel { border: 1px solid #ddd; padding: 20px; border-radius: 5px; background: #f9f9f9; }

button { background: #4CAF50; color: white; border: none; padding: 10px 15px;
         cursor: pointer; border-radius: 3px; font-size: 14px; width: 100%; margin-bottom: 5px; }
button:hover { background: #45a049; }
button.secondary { background: #008CBA; }
button.secondary:hover { background: #007399; }
button.stop { background: #f44336; }
button.stop:hover { background: #da190b; }

textarea { width: 100%; box-sizing: border-box; font-family: 'Courier New', monospace;
           padding: 10px; border: 1px solid #ddd; border-radius: 3px; font-size: 14px;
           line-height: 1.6; }
#logEditor { height: calc(100vh - 240px); min-height: 400px; }

#fileList { list-style: none; padding: 0; margin: 10px 0 0 0; max-height: 400px; overflow-y: auto;
            background: white; border: 1px solid #ddd; border-radius: 3px; }
#fileList li { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; font-size: 13px; }
#fileList li:hover { background: #e3f2fd; }
#fileList li.active { background: #4CAF50; color: white; font-weight: bold; }

#status { background: #fff3cd; padding: 12px; border-radius: 3px; margin-bottom: 15px;
          font-weight: bold; min-height: 20px; border: 2px solid #ffc107; }
#status.running { background: #d4edda; border-color: #28a745; color: #155724; }
#status.idle { background: #e7f3ff; border-color: #0066cc; color: #004085; }

.help { background: #e3f2fd; padding: 12px; border-radius: 3px; margin-bottom: 15px;
        font-size: 13px; line-height: 1.5; border-left: 4px solid #2196F3; }
.help strong { display: block; margin-bottom: 5px; color: #1976D2; }

.top-bar { display: flex; gap: 10px; align-items: center; margin-bottom: 20px; }
.top-bar button { width: auto; margin: 0; }
.folder-status { flex: 1; padding: 10px; background: #f0f0f0; border-radius: 3px;
                 font-size: 14px; }

h2 { margin: 0 0 10px 0; font-size: 16px; color: #333; }
h3 { margin: 0 0 10px 0; font-size: 18px; color: #333; }

/* Autocomplete dropdown */
#autocomplete { position: absolute; background: white; border: 2px solid #4CAF50;
                border-radius: 3px; max-height: 200px; overflow-y: auto; z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: none; min-width: 200px; }
#autocomplete div { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; }
#autocomplete div:hover, #autocomplete div.selected { background: #e3f2fd; }
#autocomplete div.selected { background: #4CAF50; color: white; }
#autocomplete .tag { font-weight: bold; color: #2196F3; }
#autocomplete .desc { font-size: 12px; color: #666; margin-left: 8px; }
#autocomplete div.selected .tag { color: white; }
#autocomplete div.selected .desc { color: #eee; }

/* Tabs */
.tabs { display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #ddd; }
.tab { padding: 10px 20px; cursor: pointer; border: none; background: transparent;
       color: #666; font-size: 15px; border-bottom: 3px solid transparent; width: auto; margin: 0; }
.tab:hover { background: #f0f0f0; color: #333; }
.tab.active { color: #4CAF50; border-bottom-color: #4CAF50; font-weight: bold; }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* Settings editors */
.settings-editors { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
.editor-section { border: 1px solid #ddd; padding: 15px; border-radius: 5px; background: white; }
.editor-section h3 { margin-top: 0; color: #4CAF50; }
.editor-section textarea { height: 300px; font-size: 13px; }
button.pause { background: #FF9800; }
button.pause:hover { background: #F57C00; }
button.hidden { display: none; }
</style>
</head>
<body>
<h1>üìö Homeschool Time Tracker</h1>

<div class="top-bar">
  <button onclick="selectFolder()">üìÅ Select Project Folder</button>
  <div class="folder-status" id="folderStatus">No folder selected - select the homeschool-timer folder</div>
</div>

<div class="container">
  <!-- Sidebar -->
  <div class="sidebar">
    <!-- Timer Controls -->
    <div class="panel">
      <h2>‚è±Ô∏è Timer</h2>
      <button id="startBtn" onclick="startInlineTimer()">‚ñ∂Ô∏è Start Timer</button>
      <button id="pauseBtn" onclick="pauseInlineTimer()" class="pause hidden">‚è∏Ô∏è Pause Timer</button>
      <button id="stopBtn" onclick="stopInlineTimer()" class="stop hidden">‚èπÔ∏è Stop Timer</button>
      <button onclick="insertTimerLine()" class="secondary">‚ûï New Timer Entry</button>
    </div>

    <!-- File Management -->
    <div class="panel">
      <h2>üìã Files</h2>
      <button onclick="createTodayLog()">üìÑ Today's Log</button>
      <button onclick="saveCurrentLog()" class="secondary">üíæ Save</button>
      <button onclick="refreshFileList()" class="secondary">üîÑ Refresh</button>
      <ul id="fileList"></ul>
    </div>
  </div>

  <!-- Main Panel with Tabs -->
  <div class="main-panel">
    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab active" onclick="switchTab('logs')">üìã Logs</button>
      <button class="tab" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
    </div>

    <!-- Logs Tab -->
    <div id="logsTab" class="tab-content active">
      <div id="status" class="idle">Type or insert a timer entry, then click Start Timer</div>

      <div class="help">
        <strong>How to use inline timers:</strong>
        1. Click "New Timer Entry" or type: <code>- [Timer] #student #subject</code><br>
        2. Add notes on the next line (optional)<br>
        3. Click "Start Timer" - it finds the most recent [Timer] entry<br>
        4. Click "Stop/Pause Timer" - replaces [Timer] with actual times<br>
        <strong>Autocomplete:</strong> Type <code>#c</code> to see all tags starting with 'c'
      </div>

      <h3>üìù <span id="currentFile">No file loaded</span></h3>
      <textarea id="logEditor" placeholder="Select the project folder and load a file to get started..."></textarea>
    </div>

    <!-- Settings Tab -->
    <div id="settingsTab" class="tab-content">
      <h3>‚úèÔ∏è Edit Students & Subjects</h3>
      <p style="margin-bottom: 15px; color: #666;">Define your hashtags here. Format: <code>#tagname - Description</code></p>

      <div class="settings-editors">
        <div class="editor-section">
          <h3>üë• Students</h3>
          <textarea id="studentsEditor" placeholder="Loading..."></textarea>
          <button onclick="saveStudents()" style="margin-top: 10px;">üíæ Save Students</button>
        </div>

        <div class="editor-section">
          <h3>üìö Subjects</h3>
          <textarea id="subjectsEditor" placeholder="Loading..."></textarea>
          <button onclick="saveSubjects()" style="margin-top: 10px;">üíæ Save Subjects</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Autocomplete dropdown -->
<div id="autocomplete"></div>

<script>
let folderHandle = null;
let currentFileHandle = null;
let currentFileName = null;
let timerStartTime = null;
let timerLineIndex = null;
let timerPausedTime = null;
let timerState = 'idle'; // idle, running, paused
let allHashtags = []; // All available hashtags from Students/ and Subjects/
let autocompleteSelectedIndex = -1;
let studentsFileHandle = null;
let subjectsFileHandle = null;

async function selectFolder() {
  try {
    folderHandle = await window.showDirectoryPicker();
    document.getElementById('folderStatus').textContent = `‚úì Selected: ${folderHandle.name}`;
    await loadHashtags();
    await loadSettingsEditors();
    await refreshFileList();
    await loadTodayLog();
  } catch(e) {
    if (e.name !== 'AbortError') {
      alert('Error selecting folder: ' + e.message);
    }
  }
}

// Tab switching
function switchTab(tabName) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

  // Show selected tab
  if (tabName === 'logs') {
    document.getElementById('logsTab').classList.add('active');
    document.querySelectorAll('.tab')[0].classList.add('active');
  } else if (tabName === 'settings') {
    document.getElementById('settingsTab').classList.add('active');
    document.querySelectorAll('.tab')[1].classList.add('active');
  }
}

// Timer button visibility
function updateTimerButtons() {
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stopBtn = document.getElementById('stopBtn');

  if (timerState === 'idle') {
    startBtn.classList.remove('hidden');
    pauseBtn.classList.add('hidden');
    stopBtn.classList.add('hidden');
  } else if (timerState === 'running') {
    startBtn.classList.add('hidden');
    pauseBtn.classList.remove('hidden');
    stopBtn.classList.remove('hidden');
  } else if (timerState === 'paused') {
    startBtn.classList.remove('hidden');
    startBtn.textContent = '‚ñ∂Ô∏è Resume Timer';
    pauseBtn.classList.add('hidden');
    stopBtn.classList.remove('hidden');
  }
}

async function loadHashtags() {
  allHashtags = [];

  try {
    // Load from Students/ and Subjects/ folders
    const folders = ['Students', 'Subjects'];

    for (const folderName of folders) {
      try {
        const subfolderHandle = await folderHandle.getDirectoryHandle(folderName);

        // Read all .md files in this folder
        for await (const entry of subfolderHandle.values()) {
          if (entry.kind === 'file' && entry.name.endsWith('.md')) {
            const fileHandle = await subfolderHandle.getFileHandle(entry.name);
            const file = await fileHandle.getFile();
            const content = await file.text();

            // Parse hashtags from the file
            const lines = content.split('\n');
            for (const line of lines) {
              // Match lines like: #tag - Description
              const match = line.match(/^(#[\w\/]+)\s*-?\s*(.*)/);
              if (match) {
                const tag = match[1];
                const desc = match[2].trim();
                allHashtags.push({ tag, desc });
              }
            }
          }
        }
      } catch(e) {
        console.log(`Folder ${folderName} not found or error reading:`, e);
      }
    }

    console.log('Loaded hashtags:', allHashtags);
  } catch(e) {
    console.log('Error loading hashtags:', e);
  }
}

// Load students and subjects into editors
async function loadSettingsEditors() {
  if (!folderHandle) return;

  try {
    // Load students
    const studentsFolder = await folderHandle.getDirectoryHandle('Students');
    studentsFileHandle = await studentsFolder.getFileHandle('students.md');
    const studentsFile = await studentsFileHandle.getFile();
    const studentsContent = await studentsFile.text();
    document.getElementById('studentsEditor').value = studentsContent;
  } catch(e) {
    console.log('Error loading students:', e);
    document.getElementById('studentsEditor').value = '# Students\n\n#student - Description\n';
  }

  try {
    // Load subjects
    const subjectsFolder = await folderHandle.getDirectoryHandle('Subjects');
    subjectsFileHandle = await subjectsFolder.getFileHandle('subjects.md');
    const subjectsFile = await subjectsFileHandle.getFile();
    const subjectsContent = await subjectsFile.text();
    document.getElementById('subjectsEditor').value = subjectsContent;
  } catch(e) {
    console.log('Error loading subjects:', e);
    document.getElementById('subjectsEditor').value = '# Subjects\n\n#subject - Description\n';
  }
}

async function saveStudents() {
  if (!studentsFileHandle) {
    alert('Students file not loaded');
    return;
  }

  try {
    const content = document.getElementById('studentsEditor').value;
    const writable = await studentsFileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    alert('‚úì Students saved!');
    await loadHashtags(); // Reload hashtags
  } catch(e) {
    alert('Error saving students: ' + e.message);
  }
}

async function saveSubjects() {
  if (!subjectsFileHandle) {
    alert('Subjects file not loaded');
    return;
  }

  try {
    const content = document.getElementById('subjectsEditor').value;
    const writable = await subjectsFileHandle.createWritable();
    await writable.write(content);
    await writable.close();
    alert('‚úì Subjects saved!');
    await loadHashtags(); // Reload hashtags
  } catch(e) {
    alert('Error saving subjects: ' + e.message);
  }
}

async function refreshFileList() {
  if (!folderHandle) return;

  const fileList = document.getElementById('fileList');
  fileList.innerHTML = '';

  const files = [];

  try {
    // Access the Logbook subfolder
    const logbookHandle = await folderHandle.getDirectoryHandle('Logbook');

    for await (const entry of logbookHandle.values()) {
      if (entry.kind === 'file' && entry.name.endsWith('.md')) {
        files.push(entry.name);
      }
    }
  } catch(e) {
    console.log('Error accessing Logbook folder:', e);
  }

  files.sort().reverse();

  if (files.length === 0) {
    const li = document.createElement('li');
    li.textContent = '(no logs yet)';
    li.style.fontStyle = 'italic';
    li.style.cursor = 'default';
    fileList.appendChild(li);
    return;
  }

  for (const filename of files) {
    const li = document.createElement('li');
    li.textContent = filename.replace('.md', '');
    li.onclick = () => loadLog(filename);
    if (filename === currentFileName) {
      li.className = 'active';
    }
    fileList.appendChild(li);
  }
}

async function loadLog(filename) {
  if (!folderHandle) return;

  try {
    const logbookHandle = await folderHandle.getDirectoryHandle('Logbook');
    currentFileHandle = await logbookHandle.getFileHandle(filename);
    const file = await currentFileHandle.getFile();
    const content = await file.text();

    document.getElementById('logEditor').value = content;
    document.getElementById('currentFile').textContent = filename;
    currentFileName = filename;

    updateStatus('üìÑ Loaded ' + filename, 'idle');
    await refreshFileList();
  } catch(e) {
    alert('Error loading file: ' + e.message);
  }
}

async function loadTodayLog() {
  const today = new Date().toISOString().slice(0, 10) + '.md';
  try {
    await loadLog(today);
  } catch(e) {
    console.log("Today's log not found");
  }
}

async function createTodayLog() {
  if (!folderHandle) {
    alert('Please select the project folder first');
    return;
  }

  const today = new Date().toISOString().slice(0, 10);
  const filename = today + '.md';

  try {
    const logbookHandle = await folderHandle.getDirectoryHandle('Logbook');
    const fileHandle = await logbookHandle.getFileHandle(filename, { create: true });
    const file = await fileHandle.getFile();
    let content = await file.text();

    if (!content.trim()) {
      content = `# ${today}\n\n## Time Log\n\n`;
      const writable = await fileHandle.createWritable();
      await writable.write(content);
      await writable.close();
    }

    await loadLog(filename);
    await refreshFileList();
  } catch(e) {
    alert('Error creating log: ' + e.message);
  }
}

async function saveCurrentLog() {
  if (!currentFileHandle) {
    alert('No file loaded');
    return;
  }

  try {
    const content = document.getElementById('logEditor').value;
    const writable = await currentFileHandle.createWritable();
    await writable.write(content);
    await writable.close();

    updateStatus(`‚úì Saved ${currentFileName}`, 'idle');
  } catch(e) {
    alert('Error saving file: ' + e.message);
  }
}

function insertTimerLine() {
  const editor = document.getElementById('logEditor');
  const cursorPos = editor.selectionStart;
  const content = editor.value;

  // Find the position to insert (end of current line or at cursor)
  let insertPos = cursorPos;

  // If we're in the middle of a line, go to the end of it
  while (insertPos < content.length && content[insertPos] !== '\n') {
    insertPos++;
  }

  // Add newline if we're not at the end of content
  const prefix = (insertPos < content.length || content[insertPos - 1] === '\n') ? '' : '\n';
  const newLine = `${prefix}- [Timer] #student #subject\n  `;

  editor.value = content.slice(0, insertPos) + newLine + content.slice(insertPos);
  editor.selectionStart = editor.selectionEnd = insertPos + newLine.length;
  editor.focus();

  updateStatus('Timer entry inserted - add your tags and notes, then click Start Timer', 'idle');
}

function startInlineTimer() {
  const editor = document.getElementById('logEditor');
  const lines = editor.value.split('\n');

  // If paused, resume
  if (timerState === 'paused') {
    timerState = 'running';
    document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Start Timer';
    updateTimerButtons();
    const timerContent = lines[timerLineIndex].replace('- [Timer]', '').trim();
    updateStatus(`‚è±Ô∏è RUNNING (resumed)... for: ${timerContent}`, 'running');
    return;
  }

  // Find the last line with [Timer]
  let timerLine = -1;
  for (let i = lines.length - 1; i >= 0; i--) {
    if (lines[i].includes('[Timer]')) {
      timerLine = i;
      break;
    }
  }

  if (timerLine === -1) {
    alert('No [Timer] entry found. Type "- [Timer] #tags" or click "New Timer Entry"');
    return;
  }

  timerStartTime = new Date();
  timerLineIndex = timerLine;
  timerState = 'running';
  updateTimerButtons();

  const timerContent = lines[timerLine].replace('- [Timer]', '').trim();
  updateStatus(`‚è±Ô∏è RUNNING... Started at ${timerStartTime.toLocaleTimeString()} for: ${timerContent}`, 'running');
}

function pauseInlineTimer() {
  if (timerState !== 'running') {
    alert('No timer running');
    return;
  }

  timerState = 'paused';
  timerPausedTime = new Date();
  updateTimerButtons();
  updateStatus('‚è∏Ô∏è PAUSED - Click Start to resume or Stop to finish', 'idle');
}

function stopInlineTimer() {
  if (!timerStartTime || timerLineIndex === null) {
    alert('No timer running. Click Start Timer first.');
    return;
  }

  const endTime = new Date();
  const startStr = timerStartTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  const endStr = endTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

  const editor = document.getElementById('logEditor');
  const lines = editor.value.split('\n');

  // Replace [Timer] with actual times
  if (timerLineIndex < lines.length && lines[timerLineIndex].includes('[Timer]')) {
    lines[timerLineIndex] = lines[timerLineIndex].replace('[Timer]', `${startStr} ‚Äì ${endStr} ‚Üí`);
    editor.value = lines.join('\n');

    updateStatus(`‚úì Timer stopped! Duration recorded: ${startStr} ‚Äì ${endStr}`, 'idle');

    // Auto-save
    if (currentFileHandle) {
      saveCurrentLog();
    }
  } else {
    alert('Timer entry was modified or deleted. Cannot update times.');
  }

  // Reset timer state
  timerStartTime = null;
  timerLineIndex = null;
  timerPausedTime = null;
  timerState = 'idle';
  document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Start Timer';
  updateTimerButtons();
}

function updateStatus(message, type) {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = type;
}

// Autocomplete functions
function showAutocomplete(prefix) {
  const dropdown = document.getElementById('autocomplete');
  const editor = document.getElementById('logEditor');

  // Filter hashtags by prefix (case insensitive)
  const filtered = allHashtags.filter(h =>
    h.tag.toLowerCase().startsWith('#' + prefix.toLowerCase())
  );

  if (filtered.length === 0) {
    dropdown.style.display = 'none';
    return;
  }

  // Populate dropdown
  dropdown.innerHTML = '';
  filtered.forEach((item, index) => {
    const div = document.createElement('div');
    div.innerHTML = `<span class="tag">${item.tag}</span><span class="desc">${item.desc}</span>`;
    div.onclick = () => insertHashtag(item.tag);
    div.dataset.index = index;
    dropdown.appendChild(div);
  });

  // Position dropdown at cursor
  const editorRect = editor.getBoundingClientRect();
  const textBeforeCursor = editor.value.substring(0, editor.selectionStart);
  const lines = textBeforeCursor.split('\n');
  const currentLine = lines.length;
  const lineHeight = 24; // approximate

  dropdown.style.left = editorRect.left + 'px';
  dropdown.style.top = (editorRect.top + (currentLine * lineHeight)) + 'px';
  dropdown.style.display = 'block';

  autocompleteSelectedIndex = 0;
  updateAutocompleteSelection();
}

function hideAutocomplete() {
  document.getElementById('autocomplete').style.display = 'none';
  autocompleteSelectedIndex = -1;
}

function updateAutocompleteSelection() {
  const dropdown = document.getElementById('autocomplete');
  const items = dropdown.querySelectorAll('div');

  items.forEach((item, index) => {
    if (index === autocompleteSelectedIndex) {
      item.classList.add('selected');
      item.scrollIntoView({ block: 'nearest' });
    } else {
      item.classList.remove('selected');
    }
  });
}

function insertHashtag(tag) {
  const editor = document.getElementById('logEditor');
  const cursorPos = editor.selectionStart;
  const text = editor.value;

  // Find the start of the current hashtag (look backwards for #)
  let hashStart = cursorPos - 1;
  while (hashStart >= 0 && text[hashStart] !== '#' && text[hashStart] !== ' ' && text[hashStart] !== '\n') {
    hashStart--;
  }

  if (text[hashStart] === '#') {
    // Replace from # to cursor with the selected tag
    editor.value = text.substring(0, hashStart) + tag + ' ' + text.substring(cursorPos);
    editor.selectionStart = editor.selectionEnd = hashStart + tag.length + 1;
  }

  hideAutocomplete();
  editor.focus();
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  const dropdown = document.getElementById('autocomplete');
  const isAutocompleteVisible = dropdown.style.display === 'block';

  // Handle autocomplete navigation
  if (isAutocompleteVisible) {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      const items = dropdown.querySelectorAll('div');
      autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
      updateAutocompleteSelection();
      return;
    }
    if (e.key === 'ArrowUp') {
      e.preventDefault();
      autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, 0);
      updateAutocompleteSelection();
      return;
    }
    if (e.key === 'Enter') {
      e.preventDefault();
      const items = dropdown.querySelectorAll('div');
      if (autocompleteSelectedIndex >= 0 && autocompleteSelectedIndex < items.length) {
        items[autocompleteSelectedIndex].click();
      }
      return;
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      hideAutocomplete();
      return;
    }
  }

  // Ctrl/Cmd + S to save
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    saveCurrentLog();
  }

  // Ctrl/Cmd + T to insert timer
  if ((e.ctrlKey || e.metaKey) && e.key === 't') {
    e.preventDefault();
    insertTimerLine();
  }
});

window.addEventListener('load', () => {
  updateStatus('üëà Select the Logbook folder to get started', 'idle');

  // Handle typing in the editor
  const logEditor = document.getElementById('logEditor');

  logEditor.addEventListener('input', (e) => {
    const editor = e.target;
    const cursorPos = editor.selectionStart;
    const text = editor.value;

    // Look backwards from cursor to find if we're typing a hashtag
    let hashStart = cursorPos - 1;
    let currentWord = '';

    while (hashStart >= 0 && text[hashStart] !== ' ' && text[hashStart] !== '\n' && text[hashStart] !== '\t') {
      currentWord = text[hashStart] + currentWord;
      hashStart--;
    }

    // Check if current word starts with #
    if (currentWord.startsWith('#') && currentWord.length > 1) {
      const prefix = currentWord.substring(1); // Remove the #
      console.log('Autocomplete triggered for:', prefix, 'Available tags:', allHashtags.length);
      showAutocomplete(prefix);
    } else {
      hideAutocomplete();
    }
  });

  // Click outside to close autocomplete
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#autocomplete') && !e.target.closest('#logEditor')) {
      hideAutocomplete();
    }
  });
});
</script>

</body>
</html>
